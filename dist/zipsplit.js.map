{
  "version": 3,
  "sources": ["../src/zipsplit.ts"],
  "sourcesContent": ["const someMaxUint32 = (...arg: number[]) => arg.some(x => x === 0xffffffff);\n\nconst readFileSlice = async (file: File, start: number, length: number) =>\n    new Promise<DataView>((resolve, reject) => {\n        const reader = new FileReader();\n        [reader.onload, reader.onerror] = [() => resolve(\n            new DataView(reader.result as ArrayBuffer)\n        ), () => reject(reader.error)];\n        reader.readAsArrayBuffer(file.slice(start, start + length));\n    });\n\nconst readFileSliceSigned = async (\n    file: File, start: number, length: number, signature: number, err: string\n) => {\n    const dv = await readFileSlice(file, start, length);\n    if(view(dv, 4) !== signature) throw new Error('invalid ' + err);\n    return dv;\n};\n\nconst view = (dataView: DataView, size: 2 | 4 | 8, offset = 0) => Number(\n    size == 2 ? dataView.getUint16(offset, true) :\n    size == 4 ? dataView.getUint32(offset, true) :\n    dataView.getBigUint64(offset, true)\n)\n\nconst sum = (arr: number[]) => arr.reduce((a, b) => a + b, 0);\n\nexport const iterateFiles = async function* (file: File) {\n    const eocdSize = 22;\n    const filesize = file.size;\n\n    if (filesize < eocdSize) throw new Error('invalid zip file');\n\n    await readFileSliceSigned(file, 0, 4, 0x04034B50, 'zip file magic');\n\n    const eocd = await readFileSliceSigned(\n        file, filesize - eocdSize, eocdSize, 0x06054b50, 'EOCD signature'\n    );\n\n    let cdOffsetSize = [16, 12].map(x => view(eocd, 4, x));\n\n    if (someMaxUint32(...cdOffsetSize)) {\n        const zip64LocatorSize = 20;\n\n        const zip64EOCDHeaderBuffer = await readFileSliceSigned(\n            file, view(await readFileSliceSigned(\n                file, filesize - eocdSize - zip64LocatorSize,\n                zip64LocatorSize, 0x07064b50, 'zip64 locator signature'\n            ), 8, 8), 56, 0x06064b50, 'zip64 eocd signature'\n        );\n\n        cdOffsetSize = [48, 40].map(x => view(zip64EOCDHeaderBuffer, 8, x));\n    }\n\n    const cd = await readFileSlice(file, ...cdOffsetSize as [number, number]);\n\n    const commentBegin = 46;\n    for (\n        let ptr = 0, lengths; ptr + commentBegin <= cd.byteLength;\n        ptr += commentBegin + sum(lengths)\n    ) {\n        if (view(cd, 4, ptr) !== 0x02014b50) throw new Error(\n            'invalid central directory file header signature'\n        );\n\n        // [uncompressedSize, compressedSize, localHeaderOffset]\n        const tmp = [24, 20, 42].map(x => view(cd, 4, ptr + x));\n\n        // [filenameLength, extraFieldLength, fileCommentLength]\n        lengths = [28, 30, 32].map(x => view(cd, 2, ptr + x));\n        const comment = [0, lengths[0]].map(x => x + ptr + commentBegin);\n\n        if (someMaxUint32(...tmp)) { // zip64\n            const end = comment[1] + lengths[1] - 4;\n\n            for (let pos = comment[1], id, size; pos < end; pos += size + 4) {\n                [id, size] = [0, 2].map(x => view(cd, 2, pos + x));\n\n                if (id === 0x0001) {\n                    for (let i = 0, offsetInBlock = 4; i < tmp.length; i++) {\n                        if (someMaxUint32(tmp[i])){ // yes, it's tmp[i]\n                            tmp[i] = view(cd, 8, pos + offsetInBlock);\n                            offsetInBlock += 8;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n\n        // compression method\n        if(view(cd, 2, ptr + 10) !== 0 || tmp[0] != tmp[1]) throw new Error(\n            `archive contains compressed file, only uncompressed supported`\n        );\n\n        const localHeader = await readFileSliceSigned(\n            file, tmp[2], 30, 0x04034b50, 'local file header signature'\n        );\n\n        yield new File(\n            [(localLengthsSum => file.slice(...[0, tmp[0]].map(\n                x => x + tmp[2] + 30 + localLengthsSum\n            )))(sum([26, 28].map(x => view(localHeader, 2, x))))],\n            new TextDecoder(\"utf-8\").decode(cd.buffer.slice(...comment))\n        );\n    }\n}\n\nexport const getAllFiles = async (file: File) => {\n    const results: File[] = [];\n    for await (const item of iterateFiles(file)) results.push(item);\n    return results;\n}"],
  "mappings": "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",
  "names": []
}
