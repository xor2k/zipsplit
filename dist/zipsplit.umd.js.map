{
  "version": 3,
  "sources": ["../src/zipsplit.ts"],
  "sourcesContent": ["const someMaxUint32 = (...arg: number[]) => arg.some(x => x === 0xffffffff);\n\nconst readFileSlice = async (file: File, start: number, length: number) =>\n    new Promise<DataView>((resolve, reject) => {\n        const reader = new FileReader();\n        [reader.onload, reader.onerror] = [() => resolve(\n            new DataView(reader.result as ArrayBuffer)\n        ), () => reject(reader.error)];\n        reader.readAsArrayBuffer(file.slice(start, start + length));\n    });\n\nconst readFileSliceSigned = async (\n    file: File, start: number, length: number, signature: number, err: string\n) => {\n    const dv = await readFileSlice(file, start, length);\n    if(view(dv, 4) !== signature) throw new Error('invalid ' + err);\n    return dv;\n};\n\nconst view = (dataView: DataView, size: 2 | 4 | 8, offset = 0) => Number(\n    size == 2 ? dataView.getUint16(offset, true) :\n    size == 4 ? dataView.getUint32(offset, true) :\n    dataView.getBigUint64(offset, true)\n)\n\nconst sum = (arr: number[]) => arr.reduce((a, b) => a + b, 0);\n\nexport const iterateFiles = async function* (file: File) {\n    const eocdSize = 22;\n    const filesize = file.size;\n\n    if (filesize < eocdSize) throw new Error('invalid zip file');\n\n    await readFileSliceSigned(file, 0, 4, 0x04034B50, 'zip file magic');\n\n    const eocd = await readFileSliceSigned(\n        file, filesize - eocdSize, eocdSize, 0x06054b50, 'EOCD signature'\n    );\n\n    let cdOffsetSize = [16, 12].map(x => view(eocd, 4, x));\n\n    if (someMaxUint32(...cdOffsetSize)) {\n        const zip64LocatorSize = 20;\n\n        const zip64EOCDHeaderBuffer = await readFileSliceSigned(\n            file, view(await readFileSliceSigned(\n                file, filesize - eocdSize - zip64LocatorSize,\n                zip64LocatorSize, 0x07064b50, 'zip64 locator signature'\n            ), 8, 8), 56, 0x06064b50, 'zip64 eocd signature'\n        );\n\n        cdOffsetSize = [48, 40].map(x => view(zip64EOCDHeaderBuffer, 8, x));\n    }\n\n    const cd = await readFileSlice(file, ...cdOffsetSize as [number, number]);\n\n    const commentBegin = 46;\n    for (\n        let ptr = 0, lengths; ptr + commentBegin <= cd.byteLength;\n        ptr += commentBegin + sum(lengths)\n    ) {\n        if (view(cd, 4, ptr) !== 0x02014b50) throw new Error(\n            'invalid central directory file header signature'\n        );\n\n        // [uncompressedSize, compressedSize, localHeaderOffset]\n        const tmp = [24, 20, 42].map(x => view(cd, 4, ptr + x));\n\n        // [filenameLength, extraFieldLength, fileCommentLength]\n        lengths = [28, 30, 32].map(x => view(cd, 2, ptr + x));\n        const comment = [0, lengths[0]].map(x => x + ptr + commentBegin);\n\n        if (someMaxUint32(...tmp)) { // zip64\n            const end = comment[1] + lengths[1] - 4;\n\n            for (let pos = comment[1], id, size; pos < end; pos += size + 4) {\n                [id, size] = [0, 2].map(x => view(cd, 2, pos + x));\n\n                if (id === 0x0001) {\n                    for (let i = 0, offsetInBlock = 4; i < tmp.length; i++) {\n                        if (someMaxUint32(tmp[i])){ // yes, it's tmp[i]\n                            tmp[i] = view(cd, 8, pos + offsetInBlock);\n                            offsetInBlock += 8;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n\n        // compression method\n        if(view(cd, 2, ptr + 10) !== 0 || tmp[0] != tmp[1]) throw new Error(\n            `archive contains compressed file, only uncompressed supported`\n        );\n\n        const localHeader = await readFileSliceSigned(\n            file, tmp[2], 30, 0x04034b50, 'local file header signature'\n        );\n\n        yield new File(\n            [(localLengthsSum => file.slice(...[0, tmp[0]].map(\n                x => x + tmp[2] + 30 + localLengthsSum\n            )))(sum([26, 28].map(x => view(localHeader, 2, x))))],\n            new TextDecoder(\"utf-8\").decode(cd.buffer.slice(...comment))\n        );\n    }\n}\n\nexport const getAllFiles = async (file: File) => {\n    const results: File[] = [];\n    for await (const item of iterateFiles(file)) results.push(item);\n    return results;\n}"],
  "mappings": "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",
  "names": []
}
